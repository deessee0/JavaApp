@startuml Class Diagram - App Padel (Completo)

title Sistema Gestione Partite Padel - Class Diagram Dettagliato

skinparam classAttributeIconSize 0
skinparam class {
  BackgroundColor<<Singleton>> LightBlue
  BackgroundColor<<Strategy>> LightYellow
  BackgroundColor<<Observer>> LightGreen
  BackgroundColor<<Entity>> White
}

' ========== MODEL LAYER ==========
package "com.example.padel_app.model" <<Rectangle>> {
  
  class User <<Entity>> {
    - id: Long {PK}
    - username: String {unique}
    - email: String {unique}
    - firstName: String
    - lastName: String
    - password: String
    - declaredLevel: Level
    - perceivedLevel: Level
    - matchesPlayed: int
    - createdMatches: List<Match>
    - registrations: List<Registration>
    __
    + getFullName(): String
    + updateMatchesCount(): void
  }
  
  class Match <<Entity>> {
    - id: Long {PK}
    - location: String
    - dateTime: LocalDateTime
    - description: String
    - requiredLevel: Level
    - type: MatchType
    - status: MatchStatus
    - creator: User {FK}
    - registrations: List<Registration>
    - feedbacks: List<Feedback>
    __
    + getActiveRegistrationsCount(): int
    + isFull(): boolean
    + isWaiting(): boolean
    + isConfirmed(): boolean
    + isFinished(): boolean
  }
  
  class Registration <<Entity>> {
    - id: Long {PK}
    - user: User {FK}
    - match: Match {FK}
    - status: RegistrationStatus
    - registeredAt: LocalDateTime
    __
    + isActive(): boolean
    + cancel(): void
  }
  
  class Feedback <<Entity>> {
    - id: Long {PK}
    - author: User {FK}
    - targetUser: User {FK}
    - match: Match {FK}
    - suggestedLevel: Level
    - comment: String
    - createdAt: LocalDateTime
    __
    {unique: author_id + target_user_id + match_id}
  }
  
  enum Level {
    PRINCIPIANTE
    INTERMEDIO
    AVANZATO
    PROFESSIONISTA
  }
  
  enum MatchType {
    PROPOSTA
    FISSA
  }
  
  enum MatchStatus {
    WAITING
    CONFIRMED
    FINISHED
    CANCELLED
  }
  
  enum RegistrationStatus {
    JOINED
    CANCELLED
  }
}

' ========== SERVICE LAYER ==========
package "com.example.padel_app.service" <<Rectangle>> {
  
  class MatchService {
    - matchRepository: MatchRepository
    - userRepository: UserRepository
    - registrationRepository: RegistrationRepository
    - registrationService: RegistrationService
    - eventPublisher: ApplicationEventPublisher
    - strategies: Map<String, MatchSortingStrategy>
    __
    + createMatch(CreateMatchRequest): Match
    + joinMatch(matchId: Long, userId: Long): Registration
    + leaveMatch(matchId: Long, userId: Long): void
    + finishMatch(matchId: Long): void
    + getAllMatches(): List<Match>
    + getMatchesSorted(sortType: String): List<Match>
    + filterByStatus(status: MatchStatus): List<Match>
    + filterByLevel(level: Level): List<Match>
    __
    - autoConfirmIfFull(match: Match): void
    - publishMatchConfirmedEvent(match: Match): void
    - publishMatchFinishedEvent(match: Match): void
  }
  
  class RegistrationService {
    - registrationRepository: RegistrationRepository
    - matchService: MatchService
    __
    + joinMatch(user: User, match: Match): Registration
    + leaveMatch(user: User, match: Match): void
    + getRegistrationsByUser(user: User): List<Registration>
    + getRegistrationsByMatch(match: Match): List<Registration>
    + getActiveRegistrationsByMatch(match: Match): List<Registration>
    + isUserRegisteredForMatch(user: User, match: Match): boolean
    + getActiveRegistrationsCount(match: Match): int
    __
    note: "Riutilizza registrations CANCELLED per evitare unique constraint violation"
  }
  
  class FeedbackService {
    - feedbackRepository: FeedbackRepository
    - userRepository: UserRepository
    - matchRepository: MatchRepository
    __
    + createFeedback(CreateFeedbackRequest): Feedback
    + updatePerceivedLevel(userId: Long): void
    + getFeedbacksForUser(userId: Long): List<Feedback>
    + getPlayersForFeedback(matchId: Long, userId: Long): List<User>
    __
    - calculateAverageLevel(feedbacks: List<Feedback>): Level
    - validateFeedback(request): void
  }
  
  class UserService {
    - userRepository: UserRepository
    __
    + createUser(User): User
    + findById(id: Long): Optional<User>
    + findAll(): List<User>
    + updateUser(User): User
  }
  
  class UserSessionService {
    __
    + saveUserInSession(user: User, session: HttpSession): void
    + getUserFromSession(session: HttpSession): Optional<User>
    + clearSession(session: HttpSession): void
    + isAuthenticated(session: HttpSession): boolean
    __
    note: "Gestione sessione HTTP per autenticazione"
  }
  
  class NotificationService <<Singleton>> {
    __
    + sendMatchConfirmedNotification(match: Match): void
    + sendMatchFinishedNotification(match: Match): void
    __
    note: "Spring @Service (singleton scope)"
  }
}

' ========== STRATEGY PATTERN ==========
package "com.example.padel_app.strategy" <<Rectangle>> {
  
  interface MatchSortingStrategy <<Strategy>> {
    + {abstract} sort(matches: List<Match>): List<Match>
  }
  
  class DateSortingStrategy <<Strategy>> {
    + sort(matches: List<Match>): List<Match>
    __
    note: "Ordina per dateTime ASC"
  }
  
  class PopularitySortingStrategy <<Strategy>> {
    + sort(matches: List<Match>): List<Match>
    __
    note: "Ordina per activeRegistrations DESC"
  }
  
  class LevelSortingStrategy <<Strategy>> {
    + sort(matches: List<Match>): List<Match>
    __
    note: "Ordina per requiredLevel ASC"
  }
}

' ========== OBSERVER PATTERN ==========
package "com.example.padel_app.event" <<Rectangle>> {
  
  class MatchConfirmedEvent extends ApplicationEvent {
    - match: Match
    - timestamp: LocalDateTime
    __
    + getMatch(): Match
    + getTimestamp(): LocalDateTime
  }
  
  class MatchFinishedEvent extends ApplicationEvent {
    - match: Match
    - timestamp: LocalDateTime
    __
    + getMatch(): Match
    + getTimestamp(): LocalDateTime
  }
}

package "com.example.padel_app.listener" <<Rectangle>> {
  
  class MatchEventListener <<Observer>> {
    - notificationService: NotificationService
    __
    + handleMatchConfirmed(event: MatchConfirmedEvent): void {@EventListener}
    + handleMatchFinished(event: MatchFinishedEvent): void {@EventListener}
  }
}

' ========== REPOSITORY LAYER ==========
package "com.example.padel_app.repository" <<Rectangle>> {
  
  interface UserRepository extends JpaRepository {
    + findByUsername(username: String): Optional<User>
    + findByEmail(email: String): Optional<User>
  }
  
  interface MatchRepository extends JpaRepository {
    + findByStatus(status: MatchStatus): List<Match>
    + findAllWithCreator(): List<Match> {@Query with JOIN FETCH}
    + findByRequiredLevel(level: Level): List<Match>
  }
  
  interface RegistrationRepository extends JpaRepository {
    + findByMatchAndUser(match: Match, user: User): Optional<Registration>
    + findByMatchAndStatus(match: Match, status: RegistrationStatus): List<Registration>
    + findByMatch(match: Match): List<Registration>
  }
  
  interface FeedbackRepository extends JpaRepository {
    + findByAuthorAndTargetUserAndMatch(author, target, match): Optional<Feedback>
    + findByTargetUser(user: User): List<Feedback>
    + findByMatch(match: Match): List<Feedback>
  }
}

' ========== CONTROLLER LAYER ==========
package "com.example.padel_app.controller" <<Rectangle>> {
  
  class AuthController {
    - userService: UserService
    - userSessionService: UserSessionService
    __
    + loginPage(): String
    + registerPage(): String
    + login(email: String, password: String, session: HttpSession): String
    + register(request: RegisterRequest, session: HttpSession): String
    + logout(session: HttpSession): String
    __
    note: "Gestisce autenticazione e registrazione"
  }
  
  class WebController {
    - matchService: MatchService
    - userService: UserService
    - registrationService: RegistrationService
    - feedbackService: FeedbackService
    - userSessionService: UserSessionService
    __
    + home(model: Model): String
    + myMatches(model: Model): String
    + matches(model: Model, status: String, sort: String): String
    + users(model: Model): String
    + createMatchForm(model: Model): String
    + createMatch(request: CreateMatchRequest): String
    + joinMatch(id: Long): String
    + leaveMatch(id: Long): String
    + finishMatch(id: Long): String
    + feedbackForm(id: Long, model: Model): String
    + submitFeedback(matchId, targetUserId, suggestedLevel, comment): String
  }
}

' ========== RELATIONSHIPS ==========

' Model relationships
User "1" -- "0..*" Match : creates >
User "1" -- "0..*" Registration : has >
User "1" -- "0..*" Feedback : writes >
User "1" -- "0..*" Feedback : receives >

Match "1" *-- "0..4" Registration : contains >
Match "1" -- "0..*" Feedback : has >
Match "*" -- "1" User : created by

Registration "*" -- "1" User
Registration "*" -- "1" Match

Feedback "*" -- "1" User : author
Feedback "*" -- "1" User : target
Feedback "*" -- "1" Match

' Service dependencies
MatchService --> MatchRepository
MatchService --> UserRepository : increments matchesPlayed >
MatchService --> RegistrationRepository : queries >
MatchService --> RegistrationService
MatchService "1" o-- "*" MatchSortingStrategy : uses strategies >
MatchService ..> MatchConfirmedEvent : <<publishes>>
MatchService ..> MatchFinishedEvent : <<publishes>>

RegistrationService --> RegistrationRepository
RegistrationService --> MatchService : delegates >

FeedbackService --> FeedbackRepository
FeedbackService --> UserRepository
FeedbackService --> MatchRepository

UserService --> UserRepository

UserSessionService --> UserRepository : queries >

' Strategy pattern
DateSortingStrategy ..|> MatchSortingStrategy : <<implements>>
PopularitySortingStrategy ..|> MatchSortingStrategy : <<implements>>
LevelSortingStrategy ..|> MatchSortingStrategy : <<implements>>

' Observer pattern
MatchEventListener ..> MatchConfirmedEvent : <<listens>>
MatchEventListener ..> MatchFinishedEvent : <<listens>>
MatchEventListener --> NotificationService : uses >

' Controller dependencies
AuthController --> UserService
AuthController --> UserSessionService : manages session >

WebController --> MatchService
WebController --> UserService
WebController --> RegistrationService
WebController --> FeedbackService
WebController --> UserSessionService : verifies auth >

' Pattern annotations
note top of MatchSortingStrategy
  **STRATEGY PATTERN**
  
  Permette di selezionare dinamicamente
  l'algoritmo di ordinamento a runtime.
  
  Context: MatchService
  Strategies: Date, Popularity, Level
end note

note top of MatchEventListener
  **OBSERVER PATTERN**
  
  Spring Event Mechanism
  
  Publisher: MatchService
  Events: MatchConfirmed, MatchFinished
  Listener: MatchEventListener
  
  Disaccoppia pubblicazione da gestione
end note

note top of NotificationService
  **SINGLETON PATTERN**
  
  Spring @Service annotation
  garantisce singleton scope
  
  Una sola istanza gestisce
  tutte le notifiche
end note

note bottom of Match
  **Business Rules:**
  - Max 4 players
  - Auto-confirm at 4th player
  - Creator can delete match
  - Status transitions:
    WAITING → CONFIRMED → FINISHED
end note

@enduml
