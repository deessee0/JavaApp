@startuml Class Diagram - App Padel (Completo)

title Sistema Gestione Partite Padel - Class Diagram Dettagliato

skinparam classAttributeIconSize 0
skinparam class {
  BackgroundColor<<Singleton>> LightBlue
  BackgroundColor<<Strategy>> LightYellow
  BackgroundColor<<Observer>> LightGreen
  BackgroundColor<<Entity>> White
}

' ========== MODEL LAYER ==========
package "com.example.padel_app.model" <<Rectangle>> {
  
  class User <<Entity>> {
    - id: Long {PK}
    - username: String {unique}
    - email: String {unique}
    - firstName: String
    - lastName: String
    - password: String
    - declaredLevel: Level
    - perceivedLevel: Level
    - matchesPlayed: int
    - createdMatches: List<Match>
    - registrations: List<Registration>
    __
    + getFullName(): String
    + updateMatchesCount(): void
  }
  
  class Match <<Entity>> {
    - id: Long {PK}
    - location: String
    - dateTime: LocalDateTime
    - description: String
    - requiredLevel: Level
    - type: MatchType
    - status: MatchStatus
    - creator: User {FK}
    - registrations: List<Registration>
    - feedbacks: List<Feedback>
    __
    + getActiveRegistrationsCount(): int
    + isFull(): boolean
    + isWaiting(): boolean
    + isConfirmed(): boolean
    + isFinished(): boolean
  }
  
  class Registration <<Entity>> {
    - id: Long {PK}
    - user: User {FK}
    - match: Match {FK}
    - status: RegistrationStatus
    - registeredAt: LocalDateTime
    __
    + isActive(): boolean
    + cancel(): void
  }
  
  class Feedback <<Entity>> {
    - id: Long {PK}
    - author: User {FK}
    - targetUser: User {FK}
    - match: Match {FK}
    - suggestedLevel: Level
    - comment: String
    - createdAt: LocalDateTime
    __
    {unique: author_id + target_user_id + match_id}
  }
  
  enum Level {
    PRINCIPIANTE
    INTERMEDIO
    AVANZATO
    PROFESSIONISTA
  }
  
  enum MatchType {
    PROPOSTA
    FISSA
  }
  
  enum MatchStatus {
    WAITING
    CONFIRMED
    FINISHED
    CANCELLED
  }
  
  enum RegistrationStatus {
    JOINED
    CANCELLED
  }
}

' ========== SERVICE LAYER ==========
package "com.example.padel_app.service" <<Rectangle>> {
  
  class MatchService {
    - matchRepository: MatchRepository
    - registrationRepository: RegistrationRepository
    - userRepository: UserRepository
    - eventPublisher: ApplicationEventPublisher
    - sortingStrategies: Map<String, MatchSortingStrategy>
    __
    + getAllMatches(): List<Match>
    + getMatchesByStatus(status: MatchStatus): List<Match>
    + getMatchesByLevel(level: Level): List<Match>
    + getMatchesOrderedBy(strategy: String): List<Match>
    + getMatchesOrderedByDate(): List<Match>
    + getMatchesOrderedByPopularity(): List<Match>
    + getMatchesOrderedByLevel(): List<Match>
    + sortMatches(matches: List<Match>, strategy: String): List<Match>
    + getMatchById(id: Long): Optional<Match>
    + saveMatch(match: Match): Match
    + deleteMatch(id: Long): void
    + checkAndConfirmMatch(match: Match): Match
    + markExpiredMatchesAsFinished(): void
    + finishMatch(matchId: Long): Match
  }
  
  class RegistrationService {
    - registrationRepository: RegistrationRepository
    - matchService: MatchService
    __
    + joinMatch(user: User, match: Match): Registration
    + leaveMatch(user: User, match: Match): void
    + getRegistrationsByUser(user: User): List<Registration>
    + getRegistrationsByMatch(match: Match): List<Registration>
    + getActiveRegistrationsByMatch(match: Match): List<Registration>
    + isUserRegisteredForMatch(user: User, match: Match): boolean
    + getActiveRegistrationsCount(match: Match): int
    __
    note: "Riutilizza registrations CANCELLED per evitare unique constraint violation"
  }
  
  class FeedbackService {
    - feedbackRepository: FeedbackRepository
    - userRepository: UserRepository
    __
    + createFeedback(author: User, targetUser: User, match: Match, suggestedLevel: Level, comment: String): Feedback
    + updatePerceivedLevel(userId: Long): void
    + getFeedbacksByTargetUser(user: User): List<Feedback>
    + getFeedbacksByAuthor(user: User): List<Feedback>
    + getFeedbacksByAuthorAndMatch(author: User, match: Match): List<Feedback>
    + getFeedbacksByMatch(match: Match): List<Feedback>
    + getFeedback(author: User, targetUser: User, match: Match): Optional<Feedback>
  }
  
  class UserService {
    - userRepository: UserRepository
    __
    + createUser(User): User
    + findById(id: Long): Optional<User>
    + findAll(): List<User>
    + updateUser(User): User
  }
  
  class UserSessionService {
    __
    + saveUserInSession(user: User, session: HttpSession): void
    + getUserFromSession(session: HttpSession): Optional<User>
    + clearSession(session: HttpSession): void
    + isAuthenticated(session: HttpSession): boolean
    __
    note: "Gestione sessione HTTP per autenticazione"
  }
  
  class NotificationService <<Singleton>> {
    __
    + sendMatchConfirmedNotification(match: Match): void
    + sendMatchFinishedNotification(match: Match): void
    __
    note: "Spring @Service (singleton scope)"
  }
}

' ========== STRATEGY PATTERN ==========
package "com.example.padel_app.strategy" <<Rectangle>> {
  
  interface MatchSortingStrategy <<Strategy>> {
    + {abstract} sort(matches: List<Match>): List<Match>
  }
  
  class DateSortingStrategy <<Strategy>> {
    + sort(matches: List<Match>): List<Match>
    __
    note: "Ordina per dateTime ASC"
  }
  
  class PopularitySortingStrategy <<Strategy>> {
    + sort(matches: List<Match>): List<Match>
    __
    note: "Ordina per activeRegistrations DESC"
  }
  
  class LevelSortingStrategy <<Strategy>> {
    + sort(matches: List<Match>): List<Match>
    __
    note: "Ordina per requiredLevel ASC"
  }
}

' ========== OBSERVER PATTERN ==========
package "com.example.padel_app.event" <<Rectangle>> {
  
  class MatchConfirmedEvent extends ApplicationEvent {
    - match: Match
    - timestamp: LocalDateTime
    __
    + getMatch(): Match
    + getTimestamp(): LocalDateTime
  }
  
  class MatchFinishedEvent extends ApplicationEvent {
    - match: Match
    - timestamp: LocalDateTime
    __
    + getMatch(): Match
    + getTimestamp(): LocalDateTime
  }
}

package "com.example.padel_app.listener" <<Rectangle>> {
  
  class MatchEventListener <<Observer>> {
    - notificationService: NotificationService
    __
    + handleMatchConfirmed(event: MatchConfirmedEvent): void {@EventListener}
    + handleMatchFinished(event: MatchFinishedEvent): void {@EventListener}
  }
}

' ========== REPOSITORY LAYER ==========
package "com.example.padel_app.repository" <<Rectangle>> {
  
  interface UserRepository extends JpaRepository {
    + findByUsername(username: String): Optional<User>
    + findByEmail(email: String): Optional<User>
  }
  
  interface MatchRepository extends JpaRepository {
    + findByStatus(status: MatchStatus): List<Match>
    + findByType(type: MatchType): List<Match>
    + findByRequiredLevel(level: Level): List<Match>
    + findAllOrderByDate(): List<Match> {@Query ORDER BY dateTime}
    + findAllOrderByPopularity(): List<Match> {@Query ORDER BY SIZE(registrations)}
    + findAllOrderByLevel(): List<Match> {@Query ORDER BY requiredLevel}
    + findByDateTimeBefore(dateTime: LocalDateTime): List<Match>
    + findByStatusAndDateTimeAfter(status: MatchStatus, dateTime: LocalDateTime): List<Match>
    + findByRequiredLevelAndStatus(level: Level, status: MatchStatus): List<Match>
    + findAllWithCreator(): List<Match> {@Query JOIN FETCH creator, registrations}
    + findByStatusWithCreator(status: MatchStatus): List<Match> {@Query JOIN FETCH}
    + findByRequiredLevelWithCreator(level: Level): List<Match> {@Query JOIN FETCH}
    + findAllOrderByDateWithCreator(): List<Match> {@Query JOIN FETCH + ORDER BY}
    + findAllOrderByPopularityWithCreator(): List<Match> {@Query JOIN FETCH + ORDER BY}
    + findAllOrderByLevelWithCreator(): List<Match> {@Query JOIN FETCH + ORDER BY}
  }
  
  interface RegistrationRepository extends JpaRepository {
    + findByUser(user: User): List<Registration>
    + findByMatch(match: Match): List<Registration>
    + findByMatchAndUser(match: Match, user: User): Optional<Registration>
    + findByMatchAndStatus(match: Match, status: RegistrationStatus): List<Registration>
    + findByUserAndMatch(user: User, match: Match): Optional<Registration>
    + findByUserAndMatchAndStatus(user: User, match: Match, status: RegistrationStatus): Optional<Registration>
    + findByUserAndStatus(user: User, status: RegistrationStatus): List<Registration>
    + existsByUserAndMatchAndStatus(user: User, match: Match, status: RegistrationStatus): boolean
    + countActiveRegistrationsByMatch(match: Match): int {@Query COUNT with status=JOINED}
    + countAllRegistrationsByMatch(match: Match): int {@Query COUNT all}
  }
  
  interface FeedbackRepository extends JpaRepository {
    + findByAuthorAndTargetUserAndMatch(author: User, targetUser: User, match: Match): Optional<Feedback>
    + findByTargetUser(user: User): List<Feedback>
    + findByAuthor(user: User): List<Feedback>
    + findByMatch(match: Match): List<Feedback>
    + findByAuthorAndMatch(author: User, match: Match): List<Feedback>
  }
}

' ========== CONTROLLER LAYER ==========
package "com.example.padel_app.controller" <<Rectangle>> {
  
  class AuthController {
    - userRepository: UserRepository
    - userSessionService: UserSessionService
    - passwordEncoder: PasswordEncoder
    __
    + loginPage(): String
    + registerPage(): String
    + login(email: String, password: String, session: HttpSession): String
    + register(request: RegisterRequest, session: HttpSession): String
    + logout(session: HttpSession): String
    __
    note: "Gestisce autenticazione con BCrypt hashing"
  }
  
  class WebController {
    - matchService: MatchService
    - userService: UserService
    - registrationService: RegistrationService
    - feedbackService: FeedbackService
    - userSessionService: UserSessionService
    __
    + home(session: HttpSession, level: String, sort: String, model: Model): String
    + myMatches(session: HttpSession, status: String, sort: String, model: Model): String
    + matches(session: HttpSession, level: String, sort: String, model: Model): String
    + users(session: HttpSession, model: Model): String
    + createMatchForm(session: HttpSession, model: Model): String
    + createMatch(session: HttpSession, request: CreateMatchRequest, model: Model): String
    + joinMatch(session: HttpSession, id: Long, redirectAttributes: RedirectAttributes): String
    + leaveMatch(session: HttpSession, id: Long, redirectAttributes: RedirectAttributes): String
    + finishMatch(session: HttpSession, id: Long, redirectAttributes: RedirectAttributes): String
    + feedbackForm(session: HttpSession, id: Long, model: Model): String
    + submitFeedback(session: HttpSession, id: Long, targetUserId: Long, suggestedLevel: String, comment: String, redirectAttributes: RedirectAttributes): String
    + myProfile(session: HttpSession, model: Model): String
    + updateDeclaredLevel(session: HttpSession, declaredLevel: String, redirectAttributes: RedirectAttributes): String
  }
}

' ========== CONFIGURATION LAYER ==========
package "com.example.padel_app.config" <<Rectangle>> {
  
  class SecurityConfig {
    __
    + passwordEncoder(): BCryptPasswordEncoder
    __
    note: "Configura BCrypt per password hashing sicuro"
  }
  
  class "<<Spring Bean>>\nBCryptPasswordEncoder" as BCryptEncoder {
    __
    + encode(password: String): String
    + matches(rawPassword: String, encodedPassword: String): boolean
    __
    note: "Algoritmo BCrypt per hashing password\n- Salt automatico\n- Iterazioni configurabili\n- Sicuro contro brute force"
  }
}

' ========== RELATIONSHIPS ==========

' Model relationships
User "1" -- "0..*" Match : creates >
User "1" -- "0..*" Registration : has >
User "1" -- "0..*" Feedback : writes >
User "1" -- "0..*" Feedback : receives >

Match "1" *-- "0..4" Registration : contains >
Match "1" -- "0..*" Feedback : has >
Match "*" -- "1" User : created by

Registration "*" -- "1" User
Registration "*" -- "1" Match

Feedback "*" -- "1" User : author
Feedback "*" -- "1" User : target
Feedback "*" -- "1" Match

' Service dependencies
MatchService --> MatchRepository
MatchService --> UserRepository : increments matchesPlayed >
MatchService --> RegistrationRepository : queries count >
MatchService "1" o-- "*" MatchSortingStrategy : uses strategies >
MatchService ..> MatchConfirmedEvent : <<publishes>>
MatchService ..> MatchFinishedEvent : <<publishes>>

RegistrationService --> RegistrationRepository
RegistrationService --> MatchService : calls checkAndConfirmMatch >

FeedbackService --> FeedbackRepository
FeedbackService --> UserRepository

UserService --> UserRepository

UserSessionService --> UserRepository : queries >

' Strategy pattern
DateSortingStrategy ..|> MatchSortingStrategy : <<implements>>
PopularitySortingStrategy ..|> MatchSortingStrategy : <<implements>>
LevelSortingStrategy ..|> MatchSortingStrategy : <<implements>>

' Observer pattern
MatchEventListener ..> MatchConfirmedEvent : <<listens>>
MatchEventListener ..> MatchFinishedEvent : <<listens>>
MatchEventListener --> NotificationService : uses >

' Controller dependencies
AuthController --> UserRepository : queries >
AuthController --> UserSessionService : manages session >
AuthController --> BCryptEncoder : hashes passwords >

WebController --> MatchService
WebController --> UserService
WebController --> RegistrationService
WebController --> FeedbackService
WebController --> UserSessionService : verifies auth >

' Security configuration
SecurityConfig ..> BCryptEncoder : <<creates bean>>

' Pattern annotations
note top of MatchSortingStrategy
  **STRATEGY PATTERN**
  
  Permette di selezionare dinamicamente
  l'algoritmo di ordinamento a runtime.
  
  Context: MatchService
  Strategies: Date, Popularity, Level
end note

note top of MatchEventListener
  **OBSERVER PATTERN**
  
  Spring Event Mechanism
  
  Publisher: MatchService
  Events: MatchConfirmed, MatchFinished
  Listener: MatchEventListener
  
  Disaccoppia pubblicazione da gestione
end note

note top of NotificationService
  **SINGLETON PATTERN**
  
  Spring @Service annotation
  garantisce singleton scope
  
  Una sola istanza gestisce
  tutte le notifiche
end note

note bottom of Match
  **Business Rules:**
  - Max 4 players
  - Auto-confirm at 4th player
  - Creator can delete match
  - Status transitions:
    WAITING → CONFIRMED → FINISHED
end note

@enduml
