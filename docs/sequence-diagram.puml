@startuml Sequence Diagram - App Padel

title Flussi Join Partita e Feedback - Sequence Diagram

actor "Giocatore" as player
participant "WebController" as web
participant "UserContext" as userCtx
participant "UserRepository" as userRepo
participant "MatchService" as matchService
participant "MatchRepository" as matchRepo
participant "RegistrationService" as regService
participant "RegistrationRepository" as regRepo
participant "FeedbackService" as feedbackService
participant "FeedbackRepository" as feedbackRepo
participant "UserService" as userService

== Join Partita ==

player -> web: POST /matches/{id}/join
activate web

web -> userCtx: getCurrentUser()
activate userCtx
userCtx -> userRepo: findByUsername("margherita")
userRepo --> userCtx: User
userCtx --> web: User
deactivate userCtx

web -> matchService: getMatchById(id)
activate matchService
matchService -> matchRepo: findById(id)
activate matchRepo
matchRepo --> matchService: Optional<Match>
deactivate matchRepo
matchService --> web: Match

deactivate matchService

web -> regService: joinMatch(user, match)
activate regService
regService -> regRepo: existsByUserAndMatchAndStatus(user, match, JOINED)
regRepo --> regService: boolean

regService -> regRepo: countActiveRegistrationsByMatch(match)
regRepo --> regService: int

regService -> regRepo: save(new Registration)
regRepo --> regService: Registration

regService -> matchService: checkAndConfirmMatch(match)
activate matchService
matchService -> regRepo: countActiveRegistrationsByMatch(match)
regRepo --> matchService: int

alt 4 giocatori raggiunti
    matchService -> matchRepo: save(match with status CONFIRMED)
    matchRepo --> matchService: Match
    note right
      Stato partita aggiornato e
      loggato via MatchService
    end note
else meno di 4 giocatori
    matchService --> regService: Match
end

deactivate matchService

regService --> web: Registration

deactivate regService

web --> player: redirect con messaggio successo

deactivate web

== Invio Feedback ==

player -> web: POST /matches/{id}/feedback
activate web

web -> userCtx: getCurrentUser()
activate userCtx
userCtx -> userRepo: findByUsername("margherita")
userRepo --> userCtx: User
userCtx --> web: User
deactivate userCtx

web -> matchService: getMatchById(id)
activate matchService
matchService -> matchRepo: findById(id)
matchRepo --> matchService: Optional<Match>
matchService --> web: Match

deactivate matchService

web -> userService: getUserById(targetUserId)
activate userService
userService -> userRepo: findById(targetUserId)
userRepo --> userService: Optional<User>
userService --> web: User

deactivate userService

web -> feedbackService: createFeedback(author, target, match, level, comment)
activate feedbackService
feedbackService -> feedbackRepo: findByAuthorAndTargetUserAndMatch(...)
feedbackRepo --> feedbackService: Optional<Feedback>

alt feedback giÃ  presente
    feedbackService --> web: eccezione
    deactivate feedbackService
else nuovo feedback
    feedbackService -> feedbackRepo: save(feedback)
    feedbackRepo --> feedbackService: Feedback

    feedbackService -> feedbackService: updatePerceivedLevel(targetUserId)
    feedbackService -> userRepo: findById(targetUserId)
    userRepo --> feedbackService: Optional<User>
    feedbackService -> feedbackRepo: findByTargetUser(target)
    feedbackRepo --> feedbackService: List<Feedback>
    feedbackService -> userRepo: save(user con livello aggiornato)
    userRepo --> feedbackService: User

    feedbackService --> web: Feedback
    deactivate feedbackService
end

web --> player: redirect /matches/{id}/feedback con flash message

deactivate web

note over player, feedbackRepo
  Pattern utilizzati:
  1. Strategy per l'ordinamento delle partite (MatchService)
  2. Aggiornamento livello percepito automatizzato
end note

@enduml
